# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MapMatching
                                 A QGIS plugin
 To come
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-04-23
        git sha              : $Format:%H$
        copyright            : (C) 2021 by LAEQ
        email                : Philippe.Apparicio@UCS.INRS.ca
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os.path
from random import random

from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.core import QgsProject
from qgis.PyQt.QtGui import QIcon, QTextCursor
from qgis.PyQt.QtWidgets import QAction
from qgis.core import QgsWkbTypes

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .map_matching_dialog import MapMatchingDialog

from .model.ui.layer_manager import LayerManager
from .model.layer import Layers
from .model.network import NetworkLayer
from .model.path import PathLayer
from .model.ui.settings import Settings
from .model.matcheur import Matcheur


class MapMatching:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]

        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'MapMatching_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'q3m.window.title')


        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        self.dlg = None
        self.manager = LayerManager()

        # @todo Investigate diff between instance and iface mapLayers
        # QgsProject.instance().mapLayers()

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass

        return QCoreApplication.translate('MapMatching', message)

    def add_action(
            self,
            icon_path,
            text,
            callback,
            enabled_flag=True,
            add_to_menu=True,
            add_to_toolbar=True,
            status_tip=None,
            whats_this=None,
            parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/map_matching/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'q3m.toolbar.title'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'q3m.window.title'),
                action)
            self.iface.removeToolBarIcon(action)

    def init_ui(self) -> None:
        """ Initialize window with translated messages"""
        if self.first_start:
            self.first_start = False
            self.dlg = MapMatchingDialog()
            self.dlg.set_manager(self.manager)

            self.settings = Settings(self.dlg)

            # Translations
            self.dlg.setWindowTitle(self.tr("q3m.window.title"))
            for label, widget in self.dlg.labels():
                label = label.replace("label_", "q3m.window.label.")
                widget.setText(self.tr(label))

            for label, widget in self.dlg.buttons():
                label = label.replace("_", ".").replace("btn", "q3m.window.btn")
                widget.setText(self.tr(label))

            for name, tab in self.dlg.tab():

                label = tab.tabText(0)
                label = label.replace("_", ".").replace("tab", "q3m.window.tab")
                tab.setTabText(0,self.tr(label))

                label = tab.tabText(1)
                label = label.replace("_", ".").replace("tab", "q3m.window.tab")
                tab.setTabText(1,self.tr(label))

            for label, widget in self.dlg.groupBox():
                label = label.replace("_", ".").replace("group", "q3m.window.group")
                widget.setTitle(self.tr(label))

            for label, widget in self.dlg.checkBox():
                if label != "check_speed":
                    label = label.replace("_", ".").replace("check", "q3m.window.check")
                    widget.setText(self.tr(label))

            #Voir si on peut pas faire mieux
            dir = os.path.dirname(__file__)
            file = os.path.abspath(os.path.join(dir, './ressources/documentation/', 'help_en.html'))
            file2 = os.path.abspath(os.path.join(dir,'./ressources/documentation/', 'help_settings_en.html'))
            if os.path.exists(file):
                with open(file2) as help2:
                    help = help2.read()
                    self.dlg.textBrowser_settings.insertHtml(help)
                    self.dlg.textBrowser_settings.moveCursor(QTextCursor.Start)

                with open(file) as helpf:
                    help = helpf.read()
                    self.dlg.textBrowser_help.insertHtml(help)
                    self.dlg.textBrowser_help.moveCursor(QTextCursor.Start)
            

            # Listeners
            self.dlg.btn_reload_layers.clicked.connect(self.reloads)
            
            self.dlg.btn_reduce_network.clicked.connect(self.on_click_reduce_network)
            self.dlg.btn_correct_topology.clicked.connect(self.on_click_correct_topology)
            
            self.dlg.btn_map_matching.clicked.connect(self.on_click_pre_matching)
            
            self.dlg.btn_reselect_path.clicked.connect(self.on_click_reSelect_path)
            self.dlg.btn_apply_path_change.clicked.connect(self.on_click_apply_modification)
            
            self.dlg.btn_export_polyline.clicked.connect(self.load)
            self.dlg.btn_reset.clicked.connect(self.reset)

            # Enabled buttons
            self.dlg.change_button_state(1)

            self.dlg.check_speed.clicked.connect(self.dlg.update_matching_box)

            # Add listener for layer deletion / dragging, ...
            # QgsProject.instance().layerTreeRoot().willRemoveChildren.connect(self.will_removed)
            # QgsProject.instance().layerTreeRoot().removedChildren.connect(self.has_removed)
            


        self.manager.set_layers(self.iface.mapCanvas().layers())
        self.dlg.update()
        self.dlg.fill_fixed_box()
        

    def will_removed(self, node, _from, _to) -> None:
        pass

    def has_removed(self, node, _from: int, _to: int) -> None:
        pass

    def run(self):
        """Run method that performs all the real work"""
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        self.init_ui()

        self.dlg.show()
        result = self.dlg.exec_()
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass

    def reloads(self):
        self.dlg.clear()
        self.manager.set_layers(self.iface.mapCanvas().layers())
        self.dlg.update()

    def load(self):
        """Load sample datas"""
        QgsProject.instance().removeAllMapLayers()
        self.dlg.remove_all_layers()

        pts_pth = os.path.join(self.plugin_dir, "ressources", "datas", "points.gpkg")
        layer = self.iface.addVectorLayer(pts_pth, "trace_{:.5f}".format(random()), "ogr")
        self.manager.add_layer(layer)

        network_path = os.path.join(self.plugin_dir, "ressources", "datas", "reseau.gpkg")
        layer = self.iface.addVectorLayer(network_path, "reseau_{:.5f}".format(random()), "ogr")
        self.manager.add_layer(layer)

        self.dlg.update()

    def reset(self):
        self.dlg.change_button_state(1)
        


    #=============================================================================#
    #==============================Processing part================================#
    #=============================================================================#
    

    def on_click_reduce_network(self):

        val = self.settings.get_settings()

        network_layer = self.manager.find_layer(val["combo_network"])
        path_layer = self.manager.find_layer(val["combo_path"])

        buffer = val["spin_buffer_range"]

        if not LayerManager.are_valid(path_layer, network_layer):
            print("error layer not valids")
            return

        network_layer = NetworkLayer(network_layer)
        path_layer = PathLayer(path_layer)


        self.layers = Layers(path_layer, network_layer)

        self.layers.reduce_network_layer(buffer)

        network = self.layers.network_layer.layer

        self.manager.add_layer(network)

        self.manager.deselect_layer(val["combo_network"])

        self.dlg.update()

        self.dlg.combo_network.setCurrentIndex(self.dlg.combo_network.findText(network.sourceName()))

        self.dlg.change_button_state(2)

    def on_click_correct_topology(self):

        if self.layers == None:
            print("Error, no layer created")
            return -1

        val = self.settings.get_settings()

        self.layers.correct_network_layer_topology( val["spin_close_call"], 
                                                    val["spin_intersection"])
        network = self.layers.network_layer.layer

        self.manager.add_layer(network)

        self.manager.remove_layer("Reduced network")

        self.dlg.change_button_state(3)

    def on_click_pre_matching(self):
        """Start the process of mapMatching after verifying the validity of the comboBox data."""
        
        settings = self.settings.get_settings()

        self.layers.network_layer.add_attribute_to_layers()

        matcheur = Matcheur(self.layers.network_layer.layer, 
                            self.layers.path_layer.layer, 
                            _OID = settings["combo_oid"])
        
        matcheur.setParameters( settings["spin_searching_radius"],
                                settings["spin_sigma"])
        path = None

        if settings["combo_algo_matching"] == "Matching with Speed":
            if(settings["check_speed"] == False):
                print("error speed disactivated and speed matching started")
                return
            
            self.layers.reduce_Path_layer(  settings["combo_speed"],
                                            settings["spin_stop_speed"])
                                            
            self.layers.match_speed(matcheur, settings["combo_speed"])

            

        elif settings["combo_algo_matching"] == "Matching closest":
            self.layers.match_closest(matcheur)

        elif settings["combo_algo_matching"] == "Matching by distance":
            self.layers.match_by_distance(matcheur)

        path = self.layers.path_layer.layer
        self.manager.add_layer(path)

        self.dlg.change_button_state(4)
        self.dlg.update_matched_path_box()

    def on_click_reSelect_path(self):
        self.layers.reSelect_path()


    def on_click_apply_modification(self):
        
        settings = self.settings.get_settings()

        matcheur = Matcheur(None, 
                            self.layers.path_layer.layer, 
                            _OID = settings["combo_oid"])

        matcheur.setParameters( settings["spin_searching_radius"],
                                settings["spin_sigma"])

        if settings["combo_algo_matching"] == "Matching with Speed" :
            if settings["check_speed"] == False:
                print("error speed not checked and use speed matching")
                return

            self.layers.reduce_Path_layer(  settings["combo_speed"],
                                            settings["spin_stop_speed"])

            self.layers.apply_modification( settings["combo_algo_matching"],
                                            matcheur,
                                            speed_column_name= settings["combo_speed"])

        else:
            self.layers.apply_modification( settings["combo_algo_matching"],
                                            matcheur)

        path = self.layers.path_layer.layer
        self.manager.add_layer(path)

        self.dlg.update_matched_path_box()